const express        = require('express');
const router         = express.Router();
const model          = require('./exploit.model.js');
const mime           = require('mime');
const path           = require('path');
const fs             = require('fs');
const R              = require('ramda');
const Exploit        = require('../../lib/db').Exploit;
const Comment        = require('../../lib/db').Comment;
const User           = require('../../lib/db').User;
const ensureLoggedIn = require('connect-ensure-login').ensureLoggedIn.bind(null, '/api/v1/users/login');



// All exploits, filter with parameter options
router.get('/', (req, res) => {
    const options = parseParameters(req);
    getExploits(undefined, options).then( results => {
        res.status((results.length > 0) ? 200 : 404).json(results);
    });
});

// retrieves a specific exploit
router.get('/:id', (req, res) => {
    res.setHeader('Content-Type', 'application/json');
    getExploits(req.params.id, R.pick(['with_comments'], req.query)).then( results => {
        res.status((results.length > 0) ? 200 : 404).end(JSON.stringify(results));
    });
});

// retrieves the attachment of an exploit
router.get('/:id/attachment', (req, res) => {
    getExploits(req.params.id).then( results => {
        if (results[0] && results[0]['file']) {
            const file = __dirname + '/../../exploitdb/' + results[0]['file'];

            const filename = path.basename(file);
            const mimetype = mime.lookup(file);

            res.setHeader('Content-disposition', 'attachment; filename=' + filename);
            res.setHeader('Content-type', mimetype);

            const filestream = fs.createReadStream(file);
            filestream.pipe(res);
        } else {
            res.status(404).end();
        }
    });
});

router.post('/:id/comments', ensureLoggedIn(), (req, res) => {
    Exploit.findById(req.params.id).then( exploit => {
        return exploit.createComment({ UserId: req.user.id, message: req.body.message })
    }).then( comment => {
        res.json({err: false, message: 'Comment created'});
    }).catch( err => {
        console.error(err);
        res.json({err: true, message: err.message});
    });
});

router.get('/:id/comments', (req, res) => {
    Comment.findAll({where: {ExploitId: req.params.id}, include: [
            {model: User, attributes: {exclude: ['password']} }
        ]})
        .then(x => {
            return res.json(x);
        })
        .catch(err => {
            console.error(err);
            res.end(err.message);
        });
});

const getExploits = (id, options) => {
    const with_comments = options && options.with_comments ? {include: [
            { model: Comment, include: [
                {model: User, attributes: {exclude: ['password']}  }
            ]}
        ]} : {};

    if (id) {
        return Exploit.findById(id, with_comments);
    }

    const {take, skip, before, after} = R.pick(['take','skip','before','after'], options);
    let where = R.compose(
        R.map(x => R.assoc(x[0], x[1], {})),
        R.toPairs,
        R.map(x => ({$like: `%${x}%`})),
        R.pick(['platform', 'type', 'description', 'author', 'port'])
    )(options);

    let query = R.merge({'order': '_date DESC'}, with_comments);
    if (take)
        query = R.merge({limit: Number(take)}, query);
    if (skip)
        query = R.merge({offset: Number(skip)}, query);
    if (before)
        where = R.append({'_date': {'$lte': new Date(`${before}-12-31`)}}, where);
    if (after)
        where = R.append({'_date': {'$gte': new Date(`${after}-1-1`)}}, where);

    return Exploit.findAll(R.merge({where}, query));
}

const parseParameters = R.compose(
    R.pick(['with_comments', 'author', 'platform', 'port', 'description', 'type', 'before', 'after', 'take', 'skip']),
    R.prop('query')
);

module.exports = router;
