const express        = require('express');
const router         = express.Router();
const model          = require('./exploit.model.js');
const mime           = require('mime');
const path           = require('path');
const fs             = require('fs');
const R              = require('ramda');
const Exploit        = require('../../lib/db').Exploit;
const Comment        = require('../../lib/db').Comment;
const Favourite      = require('../../lib/db').Favourite;
const Coordinate     = require('../../lib/db').Coordinate;
const User           = require('../../lib/db').User;
const ensureLoggedIn = require('connect-ensure-login').ensureLoggedIn.bind(null, '/api/v1/users/login');



// All exploits, filter with parameter options
router.get('/', (req, res) => {
    const options = parseParameters(req);
    getExploits(undefined, options).then( results => {
        res.status((results.length > 0) ? 200 : 404).json(results);
    });
});

// retrieves a specific exploit
router.get('/:id', (req, res) => {
    res.setHeader('Content-Type', 'application/json');
    getExploits(req.params.id, R.pick(['with_comments'], req.query)).then( results => {
        res.status((results.length > 0) ? 200 : 404).end(JSON.stringify(results));
    });
});

// retrieves the attachment of an exploit
router.get('/:id/attachment', (req, res) => {
    getExploits(req.params.id).then( results => {
        if (results[0] && results[0]['file']) {
            const file = __dirname + '/../../exploitdb/' + results[0]['file'];

            const filename = path.basename(file);
            const mimetype = mime.lookup(file);

            res.setHeader('Content-disposition', 'attachment; filename=' + filename);
            res.setHeader('Content-type', mimetype);

            const filestream = fs.createReadStream(file);
            filestream.pipe(res);
        } else {
            res.status(404).end();
        }
    });
});

router.post('/:id/comments', ensureLoggedIn(), (req, res) => {
    Exploit.findById(req.params.id).then( exploit => {
        return exploit.createComment({ UserId: req.user.id, message: req.body.message })
    }).then( comment => {
        res.json({err: false, message: 'Comment created'});
    }).catch( err => {
        console.error(err);
        res.json({err: true, message: err.message});
    });
});

router.get('/:id/comments', (req, res) => {
    Comment.findAll({where: {ExploitId: req.params.id}, include: [
            {model: User, attributes: {exclude: ['password']} }
        ]})
        .then(x => {
            return res.json(x);
        })
        .catch(err => {
            console.error(err);
            res.end(err.message);
        });
});

router.post('/:id/coordinates', (req, res) => {
    Exploit.findById(req.params.id).then( exploit => {
        return exploit.createCoordinate(R.take(['latitude', 'longitude'], req.body));
    }).then( coordinate => {
        res.json({err: false, message: 'Coordinate created'});
    }).catch( err => {
        console.error(err);
        res.json({err: true, message: err.message});
    });
});

router.delete('/:exploit_id/coordinates/:id', (req,res) => {
    Coordinate.findById(req.params.id).then(coordinate => {
        coordinate.destroy();
        res.json({err: false, message: 'Coordinate removed'});
    }).catch(err => {
        console.error(err);
        res.json({err: true, message: err.message});
    })
})

router.get('/:id/coordinates', (req, res) => {
    Exploit.findById(req.params.id, {include: [{model: Coordinate}]})
    .then( exploit => {
        res.json(exploit);
    }).catch( err => {
        console.error(err);
        res.json({err: true, message: err.message});
    });
});

router.post('/:id/favourite', ensureLoggedIn(), (req, res) => {
    Exploit.findById(req.params.id).then( exploit => {
        exploit.addFavourite(req.user);
        res.json({err: false, message: 'Exploit added to your favourites'});
    }).catch(err => {
        console.error(err);
        res.json({err: true, message: err.message});
    });
});

router.delete('/:id/favourite', ensureLoggedIn(), (req, res) => {
    Favourite.find({where: [{ExploitId: req.params.id}, {UserId: req.user.id}]}).then( favourite => {
        favourite.destroy();
        res.json({err: false, message: 'Removed exploit from your favourites'});
    }).catch(err => {
        res.json({err: true, message: `Can't remove exploit from favourites`});
    });
});

const getExploits = (id, options) => {
    const with_comments = options && options.with_comments ? {include: [
            { model: Coordinate },
            { model: Comment, include: [
                {model: User, attributes: {exclude: ['password']}  }
            ]}
        ]} : {include: [ { model: Coordinate } ]};

    if (id) {
        return Exploit.findById(id, with_comments);
    }

    const {take, skip, before, after} = R.pick(['take','skip','before','after'], options);
    let where = R.compose(
        R.map(x => R.assoc(x[0], x[1], {})),
        R.toPairs,
        R.map(x => ({$like: `%${x}%`})),
        R.pick(['platform', 'type', 'description', 'author', 'port'])
    )(options);

    let query = R.merge({'order': '_date DESC'}, with_comments);
    if (take)
        query = R.merge({limit: Number(take)}, query);
    if (skip)
        query = R.merge({offset: Number(skip)}, query);
    if (before)
        where = R.append({'_date': {'$lte': new Date(`${before}-12-31`)}}, where);
    if (after)
        where = R.append({'_date': {'$gte': new Date(`${after}-1-1`)}}, where);

    return Exploit.findAll(R.merge({where}, query));
}

const parseParameters = R.compose(
    R.pick(['with_comments', 'author', 'platform', 'port', 'description', 'type', 'before', 'after', 'take', 'skip']),
    R.prop('query')
);

module.exports = router;
